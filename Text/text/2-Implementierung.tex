\chapter{Pathcompare - Implementierung}
\label{sec:implementierung}
\section{Technischer Rahmen}

\subsection{Robot Operating System - ROS}

Innerhalb des Referenzsystems wird \gls{ROS} im Zusammenhang mit der
Steuerung des Roboters genutzt und um die, während einer Testfahrt gewonnenen Pfaddaten,
zur Verfügung zu stellen. Im Folgenden wird genauer auf die Fähigkeiten und
Ziele von \gls{ROS} eingegangen.

Obwohl der Name zunächst anderes vermuten lässt ist \gls{ROS} kein Betriebssystem im
klassischem Sinne. Es ist ein Framework, welches auf ein Betriebssystem
angewiesen ist um ausgeführt werden zu können. Es bietet aber Funktionalitäten,
die abstrahiert betrachtet Betriebsystemfunktionen ähneln. Charakteristisch ist
hierbei \gls{ROS} Fähigkeit lokal- oder nichtlokalausgeführte Programme zu Verbinden und
eine strukturierte Kommunikation zwischen diesen zu ermöglichen. Die
wesentlichen Elementareigenschaften der Grundphilosophie sind:

\begin{itemize}
  \item multi-tool Ansatz
  \item peer-to-peer Kommunikation
  \item keine feste Bindung an Programmiersprache
  \item frei und Open-Source
\end{itemize}

Multi-tool Ansatz bedeutet, dass \gls{ROS} die Fähigkeiten verschiedener
Programme und Libraries zur Verfügung stellt. Diese sind jedoch nicht fest in
den Kern von \gls{ROS} eingebaut sondern modular integriert. Als analoges Beispiel in
Hinblick auf Betriebssysteme kann man \gls{ROS} also als einen Mikrokernel
verstehen. Dies bietet den Vorteil, dass \gls{ROS} selbst vergleichsweise klein
ist und nur wirklich gebrauchte tools geladen werden müssen.
Die peer-to-peer Kommunikation bezieht sich auf die Kommunikation
zwischen diesen, in \gls{ROS} integrierten, Modulen. Diese wird durch den \gls{ROS}
Kern gesteuert. Der Kern von \gls{ROS} ist nativ in C++ implementiert, es
existieren jedoch bereits Portierungen in andere Sprachen wie Python, Octave
und Lisp um die \gls{ROS}-\gls{API} einer größeren Zahl von Entwicklern und
Projekten die Nutzung zu ermöglichen. Weitere Portierungen sollen sich in der Implementierung befinden.

%TODO hier Referenz zu ROS paper bringen oder später?

\gls{ROS} ist darüberhinaus frei Verfügbar und Open-Source. Man kann beliebige
Programme, als Module zur Erweiterung und Nutzung von \gls{ROS} hinzufügen, wie
es auch im Rahmen des Referenzsystems geschehen ist. Bei allgemeinem Nutzem und gegebener
Pflege, besteht die Möglichkeit, dass diese offiziell zu ROS hinzugefügt werden.

Um die konkreten Abläufe und Komponenten innerhalb von \gls{ROS} 
veranschaulichen zu können und damit auch den Bezug zu Pathcompare herstellen
zu können, ist es zunächst erforderlich die Begrifflichkeiten innerhalb von
\gls{ROS} zu klären. Im Folgendem werden diese aufgezeigt.

%TODO figure ROS Komponenten hinzufügen und im Text referenzieren
Im Zentrum von ROS steht der sogenannte \textit{master}. Dieser wird als
einzelne Instanz gestartet und wartet dann darauf, dass sich tools, die im
Kontext von \gls{ROS} gestartet werden, bei ihm anmelden. Ein
gestartetes tool wird innerhalb von \gls{ROS} als \textit{node} bezeichnet. 
Ist der \textit{master} nicht gestartet können auch keine \textit{nodes}
gestartet werden. Die \textit{nodes} sind also alle zunächst auf Kommunikation mit dem \textit{master}
angewiesen. Diese Kommunikation kann lokal oder nichtlokal ausgeführt werden,
d.h. der \textit{master} kann sich auch auf einem anderen Rechner wie der
\textit{node} befinden solange eine http Verbindung zwischen beiden hergestellt
werden kann. Denn das Anmelden des \textit{nodes} beim master erfolgt über einen
\gls{XML-RPC}, getragen vom http. Für den tool Entwickler auf Anwendungsebene ist diese
Kommunikation zur Anmeldung allerding völlig unsichtbar und er muss sich nicht darum kümmern.
Das Ausführen von \textit{nodes} auf unterschiedlichen Rechnern ist natürlich ebenso
möglich und wie zuvor bereits erwähnt eines der Kernfunktionen von \gls{ROS}.
Dies lässt sich vorteilhaft ausnutzen durch zum Beispiel:
\begin{itemize}
  \item Verteilung oder Auslagerung rechenintensiver \textit{nodes} auf potente Hardware
  \item Zusammenführenung von an unterschiedlichen Stellen gewonnener Daten.
\end{itemize}

So muss beispielsweise ein mobiler Roboter Bilderkennungs Aufgaben nicht selbst
ausführen, sondern kann diese an einen \textit{node} weiterleiten der auf einem
Rechencluster ausgeführt wird. Die zweite genannte Möglichkeit ist auch besonders im Bezug auf
diese Arbeit wichtig, da Pfaddaten des Roboters und der zu testenden
Sensorknoten für \textit{Pathcompare} verfügbar gemacht werden müssen.
Die Kommunikation zwischen Nodes erfolgt über sogenannte
\textit{messages}, diese enthalten die serialisierte Form der zu übertragenden Daten.
\gls{ROS} bietet in seinen Kernpakten bereits zahlreiche Definitionen für
unterschiedliche \textit{message} Typen, aber es ist auch
möglich eigene zu generieren und dies wird von
zahlreichen Paketen getan um Daten maßgeschneidert übertragen zu können. Einmal definierte \textit{message} Typen können
wiederum rekusiv in anderen \textit{message} Typen verwendet werden.
Ein Beispiel für eine message ist in \autoref{lst:transform} dargestellt; eine Transformation die in ROS geometry\_msgs
definiert ist. Sie besteht wie erkennbar aus den zwei Typen \textit{Vector3}
und \textit{Quaternion}. Letzterer beschreibt die Rotation und der erste die
Translation. Zusammengefügt ergibt dies eine Transformationsnachricht.

\begin{lstlisting}[caption=ROS transformation message, label=lst:transform]
geometry_msgs/Vector3 translation
  float64 x
  float64 y
  float64 z
geometry_msgs/Quaternion rotation
  float64 x
  float64 y
  float64 z
  float64 w
\end{lstlisting}

Soll ein \textit{node} seine \textit{messages} anderen \textit{nodes} 
senden können, so muss dies zunächst durch festlegen einer sogenannten \textit{topic} beim
\textit{master} angemeldet werden. Dann wird diese \textit{topic} für andere
\textit{nodes} im \gls{ROS} über den \textit{master} sichtbar.
Eine \textit{topic} besteht im wesentlichen aus zwei Teilen, einer
\textit{topic-id} und einem \textit{message-type}. Wobei der
\textit{message-type} angibt welcher Typ von \textit{messages} über diese
\textit{topic} verschickt wird. Die \textit{topic-id} dient zur eindeutigen
Identifikation innerhalb des \gls{ROS}. \textit{Nodes} welche \textit{messages}
einer \textit{topic} empfangen sollen, müssen diese \textit{topic} dann beim
\textit{master} abbonieren. In programmatischer Hinsicht wird beim Empfang
neuer Nachrichten innerhalb des \textit{nodes} eine festgelegte callback
Methode aufgerufen um die \textit{messages} zu bearbeiten. Treffen dabei
Nachrichten mit einer höheren Frequenz ein, als
abgearbeitet werden können, so kommt es irgendwann zu Verlusten wenn die
einstellbare Größe der \textit{message queue} überschritten wird.

Zwei weitere wichtige Begriffe in \gls{ROS} betreffen die Organisierung der
Dateien die zu den einzelnen tools gehören. Dies sind:

\begin{itemize}
  \item package
  \item stack
\end{itemize}

Ein \textit{package} beinhaltet den Code, Libraries sowie die ausführbare Datei eines
tools bzw. \textit{nodes}.
In \gls{ROS} sind für packages bestimmte Ordnerstrukturen und Dateien
festgelegt sodass mithilfe der von \gls{ROS} mitgebrachten tools \textit{packages}
leicht gebaut, gesucht und gestartet werden können. Beispielsweise basiert das 
\gls{ROS} build System auf cmake und so ist eine vorkonfigurierte
\textit{CMakeLists.txt} in jedem \textit{package} grundsätzlich enthalten. Eine Zusammenfassung mehrerer
\textit{packages} wird als \textit{stack} bezeichnet. 

\textit{Pathcompare} ist also im Bezug auf \gls{ROS}, während der Ausführung, ein
einzelner \textit{node} welcher \textit{topics} abboniert um \textit{messages}
zu empfangen. Es wird in einem
späteren Teil darauf eingegangen, welche \textit{messages} das genau sind.
Alle zum Kompilieren und Ausführen nötige Dateien sind dabei in zwei \textit{packages} namens \textit{pathcompare}
und \textit{pathcompareplugins} aufgeteilt.

%TODO figure einfügen referenzsystem im ros

\begin{itemize}
  \item Warum brauchen wir ROS?
  \item Wer entwickelt ROS? (Stanford University \& WillowGarage \& community)
  \item Was sind die Grundeigenschaften 
  \item multitool Ansatz
  \item strukturierte Kommunikation zwischen den Tools
  \item free and open source
  \item multilingual 
  \item Begrifflichkeiten des ROS (Stack, Package, Node, Master, Topic, Message)
  \item Topologie (figure: Roboter, Master, Pathcompare , Sensorknoten)
  \item plattformen: Ubuntu
  \item standard Buildsystem cmake
\end{itemize}

\subsection{Qt}

\textit{Pathcompare} ist darauf ausgelegt alle Informationen für den Nutzer in
einer Benutzeroberfläche (fortan als GUI bezeichnet) zu visualisieren.
Da die Anbindung an \gls{ROS} über C++ erfolgt, lag nahe auch die GUI in C++
umzusetzen. Dazu wurde das Qt Framework gewählt. Qt ist in C++ implementiert, wobei
allerdings auch Anbindungen für zahlreiche andere Sprachen wie z.B.
Java, C\#, Ruby oder Python existieren. Die Entwicklung von Qt begann 1991 und
%TODO Quelle anbringen
%http://my.safaribooksonline.com/0131872494/pref04?portal=oreilly#X2ludGVybmFsX0ZsYXNoUmVhZGVyP3htbGlkPTAxMzE4NzI0OTQveGlpaQ==
ist zum Zeitpunkt des Schreibens in der Version 4.7.4 verfügbar. Das Framework besteht dabei
mittlerweile nicht mehr nur aus reinen GUI Bibliotheken, sondern stellt auch
z.B. Netzwerk-, SQL- und andere Anwendungs-Bibliothken zur Verfügung.

Für die Entwicklung von \textit{Pathcompare} waren neben den GUI Bibliotheken,
besonders folgende Konzepte und Funktionen beim Entwickeln vorteilhaft: 

\begin{itemize}
  \item Signal-Slot Konzept
  \item Plattformunabhängigkeit
  \item Containerklassen mit praktischen Hilfsmethoden
  \item graphischer GUI Designer 
\end{itemize}

Auf einige dieser Punkte und deren Bezug zu Pathcompare wird nun kurz eingangen.

Das \textit{Signal-Slot} Konzept dient dazu Objekten, bestimmte Veränderungen an Objekten
mitzuteilen, welche über diese Änderung informiert werden sollen.
Es realisiert das Entwurfsmuster des \textit{Observer patterns}. 
\textit{Signal-Slot} erspart es dem Programmierer einen Verweis auf das beobachtende
Objekt, durch einen registrierenden Methodenaufruf beim aktualisierenden
Objekt, zu hinterlegen. Stattdessen emittiert, im Falle einer mitzuteilenden
Aktualisierung, das aktualisierende Object einen Methode, welche durch
einen Qt Makro als \textit{signal} ausgezeichnet ist. Bei Beobachter Objekten,
die auf dieses Signal reagieren sollen, wird dann eine als \textit{slot}
deklarierte Methode selbständig aufgerufen, sofern die Objekte, durch einen
Aufruf einer von Qt bereitgestellten, statischen Methode, verbunden wurden. 
Dieses Konzept vereinfacht die Entwicklung wegen seiner Flexibilität deutlich, allerdings ist der durch
Qt erzeugte Code, welcher bei Auflösung der Makros entsteht, aufblähend und
dadurch theoretisch langsamer bei der Ausführung als eine klassische callback Implementierung.
In der Praxis ist diese Verlangsamung aber unmerklich und wiegt nicht die
Vorteile für den Entwickler auf. Deshalb wurde das Konzept auch bei der Entwicklung von
\textit{Pathcompare} eingesetzt. 

Im Zusammenhang mit dem Signal-Slot Konzepts wurde bereits erwähnt, dass Qt C++
mit verschiedenen Makros erweitert. Diese Makros werden dabei nicht immer
direkt in gültigen C++ Code übersetzt, sondern dienen als Annotationen. Dies
hat Folgen für den Build Vorgang, denn die mit Annotationen versehenen Klassen
müssen dann zuerst, mit dem von Qt bereitgestelltem \gls{MOC} übersetzt werden.
Standardmäßig wird in \textit{Qt} das Build Programm qmake verwendet, welches
die nötigen Aufrufe des \gls{MOC} automatisch veranlasst. In Hinblick auf
\textit{Pathcompare} war aber eine Integration in das von \gls{ROS}
genutzte Build verfahren cmake notwendig. Hierbei muss beachtet werden,
dass cmake die Dateien welche einen \gls{MOC} Aufruf notwendig machen, in der
derzeitigen Version, nicht selbständig erkennt. Diese müssen manuell in der
\textit{CmakeLists.txt} deklariert werden. Die sonstige Einbindung
\textit{Qt} spezifischer Libraries und deren Verlinkung mit der Applikation ist
in cmake leicht möglich. Somit war die Verwenung von Qt in
\textit{pathcompare} kein Hindernis für die Verwendung von cmake.
Die Nutzung von cmake wird darüberhinaus, für große Projekte, von der 
Qt Dokumentation selbst empfohlen.
%TODO Quelle anbringen?

Neben dem \gls{MOC} existiert noch ein sogenannter \gls{UIC}. Dieser tritt im
Zusammenhang mit dem \textit{QtDesigner} in Erscheinung. Der
\textit{QtDesigner} ermöglicht es graphisch Qt GUIs zu erstellen. Dabei wird
eine XML Datei vom Designer erstellt, welche den Aufbau der GUI abbildet.
Der UIC ist dann dafür verantwortlich diese Datei in C++ Klassen zu übersetzen.
Auch hier muss cmake veranlasst werden zunächst für einen \gls{UIC} Aufruf
entsprechender Dateien zu sorgen.

\begin{itemize}
  \item Warum braucht Pathcompare Qt?
  \item GUI framework, native in C++ (auch Implementierungen für Java, Ruby,..)
  \item bietet auch zahlreiche nicht GUI spezifische Funktionalität
  \item cross platform
  \item native UI rendering
  \item UI designing with Qt Designer
  \item bereichert C++ durch embedded Macros (z.B. signal\&slot) -> moc compiler
  \item standard Buildsystem native qmake 
  \item Unterstützung für cmake gegeben, für große Projekte sogar empfohlen
\end{itemize}


\section{Design der Software}
Der Hauptfokus beim Design der GUI lag darauf, einfache Benutzung und
übersichtliche Darstellung, für den Nutzer zu gewährleisten.
Außerdem sollte die Software leicht erweiterbar sein.

\subsection{Überblick Gesamtsystem}

Im Folgendem wird die Software in einer Gesamtansicht dargestellt und
anschließend auf die Funktionsweise ihrer Einzelkomponenten genauer eingegangen.

Wie in vorherigen Teilen bereits erwähnt ist \textit{Pathcompare} durch
Plug-ins erweiterbar. Dadurch kann man zunächst das Gesamtsystem logisch in zwei Teile
untergliedern, nämlich in 

\begin{enumerate}
  \item Rahmen
  \item Plug-ins
\end{enumerate}

Diese Aufteilung spiegelt sich am offensichtlichsten auch in der GUI wider.
Hierbei bildet das UI des Rahmens die Grundlage für die Visualisierung von Plug-ins.
Dabei wird den Plug-ins, nachdem sie geladen wurden, ein Platz innerhalb des
Rahmens zugewiesen. Innerhalb dieses zugewiesenen Platzes können sie beliebige
eigene UI Elemente laden und haben die volle Kontrolle über diese. Konkret
gehören dabei Folgende UI Elemente zum Rahmen:

\begin{itemize}
\item Hauptfenster
\item Topic Übersicht
\item Plug-in Tab-Fenster
\end{itemize}

Das Hauptfenster dient dabei als Grundlage für die Topic Übersicht und das
Plug-in Tab-Fenster. Die Topic Übersicht und das Plug-in Tab-Fenster sind vertikal
getrennt. Die Topic-Ansicht ist dabei ganz links angeordnet, siehe   .
%TODO screenshot Gesamtansicht .
Rechts neben der Topic Übersicht schließt unmittelbar das Plug-in
Tab-Fenster an.
Wird ein Plug-in geladen, wird in diesem Tab-Fenster ein neuer Tab angelegt. Die
Fläche dieses Tabs wird diesem Plug-in dann zur Verfügung gestellt um sein UI
darauf aufzubauen. Auf Details bezüglich des Ladens der Plug-ins und deren
Funktionsweise wird in einem folgendem Abschnitt eingegangen. 
%TODO Referenz zu Plug-in Abschnitt

Die Topic Übersicht zeigt die momentan im \gls{ROS} verfügbaren Topics an. 
Um die Übersicht auf die Topics zu strukturieren ist sie derart
gestaltet, dass Topics desselben \textit{message} Typs gruppiert werden. Diese
Gruppen werden dann kompakt im Topic Übersicht Fenster angezeigt und können dort durch
den Nutzer aufgeklappt werden um alle \textit{topics} eines Typs anzuzeigen.
Dies ermöglicht es, nur solche Topics zu beobachten, die auch
tatsächlich relevant sind für den Nutzer. 

Die Platzaufteilung zwischen der Topic Übersicht und des Plug-in Tab-Fensters,
innerhalb des Hauptfensters, wurde zugunsten des Plug-in Tab-Fensters gewählt,
sodass dieses mehr Platz einnimmt.  Dies hat auch zur Folge, dass beim Vergrößern
des Hauptfensters, die Fläche des Plus-in Tab-Fensters vertikal und horizontal
vergrößert wird. Die eingenommene Fläche der Topic Übersicht wächst allerdings
nur vertikal wesentlich an. Diese Designentscheidung begründet sich darin,
dass die Plug-ins den wesentlichen Inhalt für den Nutzer präsentieren. Die
Topic Übersicht wird hingegen vermutlich nur kurzzeitig betrachtet werden und
liegt nicht im Zentrum des Interesses. Darüber hinaus ist die Topic Übersicht
sehr kompakt gestaltet und der horizontale Platzbedarf fällt gering aus.

%TODO screenshot des Rahmens mit topics einfügen


\subsection{Anbindung an ROS}

Die Hauptaufgabe des Rahmens ist es eine Anbindung an ROS zu gewährleisten.
Diese Anbindung muss es den Plug-ins ermöglichen, benötigte \textit{topics} zu
abbonieren. Für diese Anbindung ist in \textit{Pathcompare} die Klasse
\textit{ROSManager} verantwortlich. Im Konstruktor dieser Klasse wird durch
entsprechende \gls{ROS} API Aufrufe der \textit{node} \textit{pathcompare}
erstellt. Dies geschieht durch starten eines separaten Threads, da der ROS Code
in einer eigenen while-Schleife ausgeführt werden muss, die über die gesamte
Lebenszeit des \textit{nodes} bearbeitet wird. Innerhalb dieser Schleife wird
beispielsweise, das eintreffen neuer \textit{messages} von abonnierten
\textit{topics} abgearbeitet.
Zugriff der Plug-ins auf ROS spezifische Funktionalität wird komplett über den
\textit{ROSManager} gekapselt. Diese Zentralisierung ist deshalb nötig, umd den Zugriff
der verschiedenen Plug-ins, auf ROS, zu koordinieren. 
Die wichtigste Methode die durch den ROSManager dabei den Plug-ins zur
Verfügung steht, ermöglicht es eine als Parameter übergebene \textit{topic} zu
abbonieren. 
Diese Methode ist wie folgt definiert:
%TODO add figure message / topic handling gesamtübersicht
%TODO add method definition of ROSManager subscribeToTopic(..)

Beim Abonnieren einer \textit{topic} wird in ROS typischerweise direkt eine
Methode als Callback angegeben, welche eingehende \textit{messages} bearbeitet.
Bei einer einfachen Abbonierung ist es dabei zunächst nicht möglich mehrere
Callbacks zu registrieren.
In \textit{Pathcompare} bestehtehen in dieser Hinsicht allerdings zwei
Schwierigkeitn denen bei der Entwicklung begnet werden musste:

\begin{enumerate}
  \item eventuell abbonieren mehrere Plug-ins eine topic
  \item topics können von beliebigem \textit{message} Typ sein
\end{enumerate}

Gelöst wurde das Problem durch die Verwendung von
\textit{ros::message\_filter::cache}. Objekten dieser Klasse wird bei der
Initialisierung eine \textit{topic} zugewiesen. Empfangene \textit{messages}
dieser \textit{topic} werden in einem Ringpuffer mit einstellbarer größe Zwischengespeichert.
Außerdem erlaubt diese Klasse die Registrierung beliebig vieler Callbacks.
Der \textit{ROSManager} sorgt also dafür, dass für jede von den Plug-ins
benötigte \textit{topic} genau ein \textit{ros::message\_filter::cache} Objekt
existiert. Plug-ins erhalten dann einen Verweis auf dieses Objekt und können
ihren Callback registrieren.

Weitere Methoden die der ROSMaster den Plug-ins zur Verfügung stellt, werden in einem
späteren Abschnitt aufgezeigt.

Die Klasse \textit{ROSManager} sorgt außerdem dafür, dass die Topic Übersicht
regelmäßig aufgefrischt wird. Es wird also dem Nutzer ersichtlich, sollten neue
\textit{topics} erscheinen oder wenn diese nicht mehr verfügbar sind.
Da die \gls{ROS} \gls{API} keinen event service anbietet um Beobachter zu benachrichtigen,
falls sich der Status von \textit{topics} ändert, stellt der
\textit{ROSManager} sekündlich eine Anfrage an den \textit{master} nach dem
aktuellen Stand der topics.  Dies ist gesteuert über einen QTimer in Verbindung
mit dem Signal-Slot Konzept.


\subsection{Laden von Plugins}
Das Einbinden von Plugins in den Rahmen steuert die Klasse
\textit{PluginLoader}. Sie sucht dabei in einem Verzeichnis nach als Plug-in
infrage kommenden Dateien. Bei dieser Suche werden generell nur shared Library
Dateien betrachtet. Handelt es sich um eine für \textit{Pathcompare} gültige
Plug-in Datei, fragt der \textit{PluginLoader} zunächst den Namen des Plug-ins
über eine im Plug-in Interface spezifizierte Methode \textit{getName()} ab.
Anschließend wird im Plug-in Tab Fenster ein neuer Tab angelegt. Dabei wird im
Tab Reiter der erfragte Name des Plug-ins eingetragen. Dadurch sind in der GUI die Plug-ins für den
Nutzer leicht zu unterscheiden und können schnell angewählt werden.
Der Plug-in Ordner steht während der Laufzeit von \textit{Pathcompare}
unter der Beobachtung des \textit{PluginLoaders}. 
Obwohl \textit{Pathcompare} bereits gestartet wurde, können also Plug-ins in das Plug-in
Verzeichnis eingefügt werden und diese werden geladen. Dies bietet mehr Flexibilität für den
Nutzer und Entwickler, da kein Neustart der Rahmen Anwendung sowie der ausgeführten
\textit{Plug-ins} erforderlich ist.


\subsection{Main Compare Plug-in}
\label{sub:maincompare}


\textit{Main Compare} implementiert die eigentliche Hauptfunktionalität um Pfaddaten des
Referenzsystems und der Sensorknoten zu vergleichen und auszuwerten. 
Es ist dabei der Philosophie von \textit{Pathcompare} folgend auch als Plug-in
implementiert worden, welches beim Starten des Rahmens durch den
\textit{PluginLoader} geladen und ausgeführt wird.

In der GUI werden dem Nutzer verschiedene Informationen sowie
Einstellungsmöglichkeiten bezüglich der
empfangenen Pfaddaten angezeigt. Die Funktionen der einzelnen GUI Elemente
werden im Folgenden aufgezeigt.
Insgesamt gibt es drei Bereiche in der GUI, welche sich anhand dreier
verschiedener Labels abgrenzen lassen. Von oben nach untern gesehen sind
dies die Bereiche:

\begin{enumerate}
  \item Reference path selection
  \item Export results
  \item Results
\end{enumerate}

%TODO verweis auf screenshot des Plugins einfügen
%screenshot des Plugins

Der Bereich der ``Reference path selection'' beinhaltet eine Combo-Box, welche
alle über ROS verfügbaren \textit{topics} des Typs nav\_msgs/Path beinhaltet.
Der Nutzer kann dann aus dieser Liste einen Pfad auswählen, der als
Referenzpfad genutzt werden soll. Das bedeutet, dass der ausgewählte Pfad als
Referenz für die übrigen Pfade gilt. So werden dann die Abstandsberechnungen
bezüglich dieses Pfades durchgeführt. Die Auswahl des Referenzpfades kann
jederzeit geändert werden, und die Abstände werden stets neu berechnet.

Unterhalb des ``reference path selection'' Bereichs befindet sich der ``Export
results'' Bereich. Er dient dem Nutzer dazu, die berechneten und
im ``Results'' Bereich visualisierten Ergebnisse, permanent zu speichern.
Die Speicherung erfolgt dabei als \gls{CSV} Datei. Der Export wird durchgeführt
wenn der Nutzer den in diesem Bereich vorhandenen Button drückt. 
Das genaue Format der gespeicherten Daten wird später erläutert.
%TODO verweis auf den Abschnitt ``format CSV Datei'' anbringen 

Der ``Result'' Bereich dient dazu alle ermittelten Informationen bezüglich der
Pfade, für den Nutzer anzuzeigen. Die Visualisierung erfolgt hierbei durch eine
Tabbellenstruktur. In dieser Tabelle wird für jede Path topic ein Spalte
angelegt.
In jeder Zeile einer Spalte sind dabei die unterschiedlichen
Informationen eingetragen.
Main Compare verhält sich außerdem so, dass topics, welche einmal in
der Tabelle erfasst wurden auch dort verbleiben. Sollte also eine topic nicht
mehr im ROS zur verfügung stehen, bleiben die angezeigten Informationen auf
Basis der zuletzt empfangenen Werte dennoch erhalten. 

In der Tabelle werden für den Nutzer folgende Informationen:
angezeigt:

\begin{itemize}
  \item Anzahl der Lokalisierungen
  \item Berechnung der Pfadlänge
  \item Anzeige des Medians der Abstände
  \item Anzeige des arithmetischen Mittels der Abstände
  \item Berechnung der empirische Varianz $s^2$ der Abstände
  \item Berechnung der empirische Standardabweichung $s$ der Abstände
  \item 20 größten Abstände zu Referenzpfad
\end{itemize}

Die angezeigten Informationen werden bei Empfang neuer Pfad \textit{messages} stets
aktualisiert. Generell gilt dabei, dass jede Path message den kompletten Pfad
enthalten muss. Pfade können also nicht stückweise übertragen werden. Dieses vorgehen
bietet die Möglichkeit, dass Pfaddatenen nachträglich geändert werden können.
Also kann beispielsweise die erste Lokalisierung innerhalb eines Pfades zu einem
späteren Zeitpunkt abgeändert werden. 

Um nachzuvollziehen wie die in Main Compare angezeigten Informationen ermittelt werden, bietet
es sich an, zunächst den Typ der \textit{messages}, welche über die Pfad topics
empfangen werden, zu analysieren. Denn auf dieser Basis leiten sich alle
ermittelten Informationen ab. Wie bereits beschrieben sind die messages vom Typ
\textit{nav\_msgs/Path}, der wie folgt definiert ist:

\begin{lstlisting}[caption=ROS transformation message, label=lst:pathmsgs]
Header header
  uint32 seq
  time stamp
  string frame_id
geometry_msgs/PoseStamped[] poses
  Header header
    uint32 seq
    time stamp
    string frame_id
  geometry_msgs/Pose pose
    geometry_msgs/Point position
      float64 x
      float64 y
      float64 z
    geometry_msgs/Quaternion orientation
      float64 x
      float64 y
      float64 z
      float64 w
\end{lstlisting}

Zunächst ist in \autoref{lst:pathmsgs} zu erkennen, dass sich dieser \textit{message} Typ aus anderen Typen
zusammensetzt. Auf der obersten Ebene ist dies ein
\textit{Header} und ein Array von \textit{geometry\_msgs/PoseStamped}.
Der Header dient dazu, die Path message von anderen empfangenen
Path messages zu unterscheiden und dazu die messages ordnen zu können. Die Ordnung kann dabei über eine Sequenznummer
(seq) oder einen Zeitstempel (stamp) hergestellt werden. Das Feld frame\_id
definiert einen Bezugsrahmen innerhalb von ROS, es wird aber im Kontext von
Main Compare nicht ausgewertet und wird hier deswegen nicht genauer erläutert.
Die eigentlichen Pfaddaten verbergen sich in dem Array von PoseStamped. Auch
PoseStamped ist ein zusammengesetzer Typ, bestehend aus einem Header und einer
Pose. Die Pose setzt sich aus einem Point und einer Quaternion zusammen.
Der gefahrende Pfad wird nun dadurch in der Path message abgebildet, indem bei
jeder durchgeführten Lokalisierung eine PoseStamped angelegt wird. Diese PoseStamped
hält im Header die Zeit der Lokalisierung und eine Sequenznummer fest. In der
Pose wird dann der bei der Lokalisierung ermittelte Punkt, als Point eingetragen. Die Quaternion
hält fest, welche Ausrichtung dabei im Raum vorliegt und wird auch
in die Pose eingefügt. Die Ausrichtung ist
allerdings optional und wird in der derzeitigen Version von Main Compare nicht beachtet. 
Außerdem lässt sich in \autoref{lst:pathmsgs} erkennen, dass die
Lokalisierungen dreidimensional erfolgen können. Die von Main Compare
ausgeführten Berechnungen sind aber auch mit Daten niederer Dimension möglich,
indem die nicht genutze Dimension auf 0 gesetzt wird. Beispielsweise werden,
in der derzeitigen Form des Referenzsystems, vom Roboter zweidimensionale
Lokalisierungsdaten in der x-y Ebene übermittelt und die z Komponente erhält
immer den Wert 0. Wie schon in Bezug auf die orientation erwähnt, werden nicht alle Komponenten der
Pfad message in Main Compare verwendet. Für die derzeitige Version sind
folgende Felder relevant:

\begin{itemize}
  \item poses.stamp (Typ ros::time)
  \item pose.position.x (Typ float64)
  \item pose.position.y (Typ float64)
  \item pose.position.z (Typ float64)
\end{itemize}

Obwohl nicht alle Felder der Path message genutzt werden, ist dieser message Typ
für Main Compare die geeignete Wahl, da er in ROS standardmäßig
definiert ist, was die Definition und deren Verteilung, eines
eigenen message Typs, vermeidbar macht. Außerdem sind die ungenutzen Felder nicht
übermäßig groß und werden die Kapazitäten des Übertragungskanals kaum belasten.
Vernachlässigt man die ungenutzten Felder des Header, der eine in ROS definierte Standardmessage ist, fallen nur
zusätzliche 24 Byte für die ungenutze orientation, pro übertragenem Point, an.
Darüberhinaus ist es denkbar, dass die orientation in späteren Versionen von
Main Compare doch noch betrachtet wird und somit die durchzuführenden
Änderungen klein ausfallen.

Anhand der oben aufgezählten, genutzen Felder, lässt sich ein Pfad abstrakt durch eine Menge
$M$ von Tupeln modellieren. Dabei setzen sich die Tupel aus einem Zeitstempel und einem dreidimensionalem
Punkt zusammen. In Anlehnung an die verwendeten Bezeichner in
\autoref{lst:pathmsgs}, sei $M$ demnach wie folgt definiert:

\begin{equation*}
  \label{eqn:setdef}
  M := \{ (p.stamp , p.position) \mid p \in poses \}
\end{equation*}

Die konkrete Repräsentierung dieses Modells erfolgt in Main Compare durch die
Klassen \textit{TopicPath} und \textit{Position}. TopicPath repräsentiert dabei
die Menge $M$. Position repräsentiert ein einzelnes Tupel und enthält somit den
Zeitstempel und zugehörigen Punkt. Dem Modell entsprechend enthält ein
TopicPath Objekt eine Liste von Position Objekten.  Neben den Klassen TopicPath
und Position gibt es noch eine Klasse \textit{TopicPathManager}. Es wird genau
ein Objekt dieser Klasse für jede im ROS verfügbare Path topic angelegt. Diese
Klasse bietet eine callback Methode, welche beim, zur topic gehörenden,
message\_filter::cache registriert wird. Kommt eine neue message an, wird die
callback Methode aufgerufen und aus den Werten der Path message ein neues
TopicPath Objekt erstellt. Anschließend werden, anhand des neuen TopicPaths,
alle nötigen Berechnungen erneut durchgeführt und die Results Tabelle
aktualisiert.

%TODO Klassendiagramm bezüglich der Klassen Position, TopicPath, TopicPathManager

Anhand der abstrakten Modellierung $M$ eines Pfades, werden im Folgenden, die von
Main Compare ausgeführten Berechnungen erläutert. In der konkreten
Repräsentatio erfolgen alle Berechnungen in der Klasse \textit{TopicPathManager}. 

\subsubsection{Anzahl der Lokalisierungen}
Um die Anzahl der Lokalisierungen zu ermitteln wird in Main Compare lediglich die
Mächtigkeit der Menge $M$ bestimmt. Es gilt also:

\begin{equation*}
  \label{eqn:numofpoints}
  number of points = \vert M \vert
\end{equation*}

Im \textit{TopicPathManager} ist dies entsprechend einfach realisiert.
%Siehe dazu TopicPathManager::

\subsubsection{Berechnung der Pfadlänge}
Bei der Bestimmung der Pfadlänge werden zunächst alle Abstände, zwischen je
zwei direkt aufeinanderfolgenden Punkten im Pfad, bestimmt. Die Summe all dieser
Abstände entspricht dann der Gesamtlänge des Pfades. Dazu muss jedoch noch
geklärt werden, wann ein Punkt $p_1$ in einer Path message auf einen anderen
Punkt $p_2$ folgt. Das lässt sich über den Zeitstempel feststellen und ist
anschaulich ausgedrückt dann der Fall, wenn keine weitere Lokalisierung in
der Zeit zwischen der Lokalisierung $p_1$ und $p_2$ stattgefunden hat. Dies kann man auch wie
folgend, abstrakt und bezogen auf $M$, ausdrücken.  Ein Punkt $p_2$ ist direkt
folgend auf einen Punkt $p_1$, genau dann wenn für die zugehörigen Tupel

$t_1 := (z_1, p_1)$ und $t_2 := (z_2, p_2)$
mit
$t_1,t_2 \in M$
gilt, dass:
\[
z_2 > z_1 \wedge \nexists (z^{,}, p^{,}) \in M : z_2 > z^{,} > z_1
\]

Der Abstand zweier aufeinanderfolgender Punkte lässt sich einfach durch
Vektorsubtraktion und anschließende Betragsbildung des resultierenden Vektors
bestimmen.
%TODO Siehe dazu TopicPathManager::

\subsubsection{Pfadvergleichsverfahren und Abstandsberechnung}
Das Hauptziele von Main Compare ist es, dem Nutzer zu erleichtern, die
Genauigkeit eines durch Lokalisierung gewonnenen Pfades, in Bezug auf einen
Referenzpfad, abzuschätzen. Um dies zu tun, ist es notwendig, den Abstand von
Lokalisierungen des zu untersuchenden Pfads, zu denen des Referenzpfads, zu
ermitteln. In einem naiven Ansatz könnte man die Lokalisierungen direkt
miteinander vergleichen, d.h. für jeden Punkt des Referenzpfades existiert auch
ein Punkt im zu vergleichenden Pfad mit demselben timestamp. Dies wäre in einem
Ansatz wie in  gezeigt möglich.
%TODO bild test mit Tickgeber

%TODO bild variante ohne tick

\subsubsection{Bestimmung empirischer Varianz}

\subsubsection{Bestimmung des Median der Abstände}

\subsection{Plug-in Konzept allgemein}
\begin{itemize}
  \item allgemein Qt Plugins
  \item Vorstellen der Interfaces zum Schreiben eigener Plug-ins für Pathcompare
  \item Beispiel Camera Plugin
\end{itemize}
