\chapter{Pathcompare - Implementierung}
\label{sec:implementierung}
\section{Technischer Rahmen}

\subsection{Robot Operating System - ROS}

Innerhalb des Referenzsystems wird \gls{ROS} im Zusammenhang mit der
Steuerung des Roboters genutzt und um die, während einer Testfahrt gewonnenen Pfaddaten,
zur Verfügung zu stellen. Im Folgenden wird genauer auf die Fähigkeiten und
Ziele von \gls{ROS} eingegangen.

Obwohl der Name zunächst anderes vermuten lässt ist \gls{ROS} kein Betriebssystem im
klassischem Sinne. Es ist ein Framework, welches auf ein Betriebssystem
angewiesen ist um ausgeführt werden zu können. Es bietet aber Funktionalitäten,
die abstrahiert betrachtet Betriebsystemfunktionen ähneln. Charakteristisch ist
hierbei \gls{ROS} Fähigkeit lokal- oder nichtlokalausgeführte Programme zu Verbinden und
eine strukturierte Kommunikation zwischen diesen zu ermöglichen. Die
wesentlichen Elementareigenschaften der Grundphilosophie sind:

\begin{itemize}
  \item multi-tool Ansatz
  \item peer-to-peer Kommunikation
  \item keine feste Bindung an Programmiersprache
  \item frei und Open-Source
\end{itemize}

Multi-tool Ansatz bedeutet, dass \gls{ROS} die Fähigkeiten verschiedener
Programme und Libraries zur Verfügung stellt. Diese sind jedoch nicht fest in
den Kern von \gls{ROS} eingebaut sondern modular integriert. Als analoges Beispiel in
Hinblick auf Betriebssysteme kann man \gls{ROS} also als einen Mikrokernel
verstehen. Dies bietet den Vorteil, dass \gls{ROS} selbst vergleichsweise klein
ist und nur wirklich gebrauchte tools geladen werden müssen.
Die peer-to-peer Kommunikation bezieht sich auf die Kommunikation
zwischen diesen, in \gls{ROS} integrierten, Modulen. Diese wird durch den \gls{ROS}
Kern gesteuert. Der Kern von \gls{ROS} ist nativ in C++ implementiert, es
existieren jedoch bereits Portierungen in andere Sprachen wie Python, Octave
und Lisp um die \gls{ROS}-\gls{API} einer größeren Zahl von Entwicklern und
Projekten die Nutzung zu ermöglichen. Weitere Portierungen sollen sich in der Implementierung befinden.

%TODO hier Referenz zu ROS paper bringen oder später?

\gls{ROS} ist darüberhinaus frei Verfügbar und Open-Source. Man kann beliebige
Programme, als Module zur Erweiterung und Nutzung von \gls{ROS} hinzufügen, wie
es auch im Rahmen des Referenzsystems geschehen ist. Bei allgemeinem Nutzem und gegebener
Pflege, besteht die Möglichkeit, dass diese offiziell zu ROS hinzugefügt werden.

Um die konkreten Abläufe und Komponenten innerhalb von \gls{ROS} 
veranschaulichen zu können und damit auch den Bezug zu Pathcompare herstellen
zu können, ist es zunächst erforderlich die Begrifflichkeiten innerhalb von
\gls{ROS} zu klären. Im Folgendem werden diese aufgezeigt.

%TODO figure ROS Komponenten hinzufügen und im Text referenzieren
Im Zentrum von ROS steht der sogenannte \textit{master}. Dieser wird als
einzelne Instanz gestartet und wartet dann darauf, dass sich tools, die im
Kontext von \gls{ROS} gestartet werden, bei ihm anmelden. Ein
gestartetes tool wird innerhalb von \gls{ROS} als \textit{node} bezeichnet. 
Ist der \textit{master} nicht gestartet können auch keine \textit{nodes}
gestartet werden. Die \textit{nodes} sind also alle zunächst auf Kommunikation mit dem \textit{master}
angewiesen. Diese Kommunikation kann lokal oder nichtlokal ausgeführt werden,
d.h. der \textit{master} kann sich auch auf einem anderen Rechner wie der
\textit{node} befinden solange eine http Verbindung zwischen beiden hergestellt
werden kann. Denn das Anmelden des \textit{nodes} beim master erfolgt über einen
\gls{XML-RPC}, getragen vom http. Für den tool Entwickler auf Anwendungsebene ist diese
Kommunikation zur Anmeldung allerding völlig unsichtbar und er muss sich nicht darum kümmern.
Das Ausführen von \textit{nodes} auf unterschiedlichen Rechnern ist natürlich ebenso
möglich und wie zuvor bereits erwähnt eines der Kernfunktionen von \gls{ROS}.
Dies lässt sich vorteilhaft ausnutzen durch zum Beispiel:
\begin{itemize}
  \item Verteilung oder Auslagerung rechenintensiver \textit{nodes} auf potente Hardware
  \item Zusammenführenung von an unterschiedlichen Stellen gewonnener Daten.
\end{itemize}

So muss beispielsweise ein mobiler Roboter Bilderkennungs Aufgaben nicht selbst
ausführen, sondern kann diese an einen \textit{node} weiterleiten der auf einem
Rechencluster ausgeführt wird. Die zweite genannte Möglichkeit ist auch besonders im Bezug auf
diese Arbeit wichtig, da Pfaddaten des Roboters und der zu testenden
Sensorknoten für \textit{Pathcompare} verfügbar gemacht werden müssen.
Die Kommunikation zwischen Nodes erfolgt über sogenannte
\textit{messages}, diese enthalten die serialisierte Form der zu übertragenden Daten.
\gls{ROS} bietet in seinen Kernpakten bereits zahlreiche Definitionen für
unterschiedliche \textit{message} Typen, aber es ist auch
möglich eigene zu generieren und dies wird von
zahlreichen Paketen getan um Daten maßgeschneidert übertragen zu können. Einmal definierte \textit{message} Typen können
wiederum rekusiv in anderen \textit{message} Typen verwendet werden.
Ein Beispiel für eine message ist in \autoref{lst:transform} dargestellt; eine Transformation die in ROS geometry\_msgs
definiert ist. Sie besteht wie erkennbar aus den zwei Typen \textit{Vector3}
und \textit{Quaternion}. Letzterer beschreibt die Rotation und der erste die
Translation. Zusammengefügt ergibt dies eine Transformationsnachricht.

\begin{lstlisting}[caption=ROS transformation message, label=lst:transform]
geometry_msgs/Vector3 translation
  float64 x
  float64 y
  float64 z
geometry_msgs/Quaternion rotation
  float64 x
  float64 y
  float64 z
  float64 w
\end{lstlisting}

Soll ein \textit{node} seine \textit{messages} anderen \textit{nodes} 
senden können, so muss dies zunächst durch festlegen einer sogenannten \textit{topic} beim
\textit{master} angemeldet werden. Dann wird diese \textit{topic} für andere
\textit{nodes} im \gls{ROS} über den \textit{master} sichtbar.
Eine \textit{topic} besteht im wesentlichen aus zwei Teilen, einer
\textit{topic-id} und einem \textit{message-type}. Wobei der
\textit{message-type} angibt welcher Typ von \textit{messages} über diese
\textit{topic} verschickt wird. Die \textit{topic-id} dient zur eindeutigen
Identifikation innerhalb des \gls{ROS}. \textit{Nodes} welche \textit{messages}
einer \textit{topic} empfangen sollen, müssen diese \textit{topic} dann beim
\textit{master} abbonieren. In programmatischer Hinsicht wird beim Empfang
neuer Nachrichten innerhalb des \textit{nodes} eine festgelegte callback
Methode aufgerufen um die \textit{messages} zu bearbeiten. Treffen dabei
Nachrichten mit einer höheren Frequenz ein, als
abgearbeitet werden können, so kommt es irgendwann zu Verlusten wenn die
einstellbare Größe der \textit{message queue} überschritten wird.

Zwei weitere wichtige Begriffe in \gls{ROS} betreffen die Organisierung der
Dateien die zu den einzelnen tools gehören. Dies sind:

\begin{itemize}
  \item package
  \item stack
\end{itemize}

Ein \textit{package} beinhaltet den Code, Libraries sowie die ausführbare Datei eines
tools bzw. \textit{nodes}.
In \gls{ROS} sind für packages bestimmte Ordnerstrukturen und Dateien
festgelegt sodass mithilfe der von \gls{ROS} mitgebrachten tools \textit{packages}
leicht gebaut, gesucht und gestartet werden können. Beispielsweise basiert das 
\gls{ROS} build System auf cmake und so ist eine vorkonfigurierte
\textit{CMakeLists.txt} in jedem \textit{package} grundsätzlich enthalten. Eine Zusammenfassung mehrerer
\textit{packages} wird als \textit{stack} bezeichnet. 

\textit{Pathcompare} ist also im Bezug auf \gls{ROS}, während der Ausführung, ein
einzelner \textit{node} welcher \textit{topics} abboniert um \textit{messages}
zu empfangen. Es wird in einem
späteren Teil darauf eingegangen, welche \textit{messages} das genau sind.
Alle zum Kompilieren und Ausführen nötige Dateien sind dabei in zwei \textit{packages} namens \textit{pathcompare}
und \textit{pathcompareplugins} aufgeteilt.

%TODO figure einfügen referenzsystem im ros

\begin{itemize}
  \item Warum brauchen wir ROS?
  \item Wer entwickelt ROS? (Stanford University \& WillowGarage \& community)
  \item Was sind die Grundeigenschaften 
  \item multitool Ansatz
  \item strukturierte Kommunikation zwischen den Tools
  \item free and open source
  \item multilingual 
  \item Begrifflichkeiten des ROS (Stack, Package, Node, Master, Topic, Message)
  \item Topologie (figure: Roboter, Master, Pathcompare , Sensorknoten)
  \item plattformen: Ubuntu
  \item standard Buildsystem cmake
\end{itemize}

\subsection{Qt}

\textit{Pathcompare} ist darauf ausgelegt alle Informationen für den Nutzer in
einer Benutzeroberfläche (fortan als GUI bezeichnet) zu visualisieren.
Da die Anbindung an \gls{ROS} über C++ erfolgt, lag nahe auch die GUI in C++
umzusetzen. Dazu wurde das Qt Framework gewählt. Qt ist in C++ implementiert, wobei
allerdings auch Anbindungen für zahlreiche andere Sprachen wie z.B.
Java, C\#, Ruby oder Python existieren. Die Entwicklung von Qt begann 1991 und
%TODO Quelle anbringen
%http://my.safaribooksonline.com/0131872494/pref04?portal=oreilly#X2ludGVybmFsX0ZsYXNoUmVhZGVyP3htbGlkPTAxMzE4NzI0OTQveGlpaQ==
ist zum Zeitpunkt des Schreibens in der Version 4.7.4 verfügbar. Das Framework besteht dabei
mittlerweile nicht mehr nur aus reinen GUI Bibliotheken, sondern stellt auch
z.B. Netzwerk-, SQL- und andere Anwendungs-Bibliothken zur Verfügung.

Für die Entwicklung von \textit{Pathcompare} waren neben den GUI Bibliotheken,
besonders folgende Konzepte und Funktionen beim Entwickeln vorteilhaft: 

\begin{itemize}
  \item Signal-Slot Konzept
  \item Plattformunabhängigkeit
  \item Containerklassen mit praktischen Hilfsmethoden
  \item graphischer GUI Designer 
\end{itemize}

Auf einige dieser Punkte und deren Bezug zu Pathcompare wird nun kurz eingangen.

Das \textit{Signal-Slot} Konzept dient dazu Objekten, bestimmte Veränderungen an Objekten
mitzuteilen, welche über diese Änderung informiert werden sollen.
Es realisiert das Entwurfsmuster des \textit{Observer patterns}. 
\textit{Signal-Slot} erspart es dem Programmierer einen Verweis auf das beobachtende
Objekt, durch einen registrierenden Methodenaufruf beim aktualisierenden
Objekt, zu hinterlegen. Stattdessen emittiert, im Falle einer mitzuteilenden
Aktualisierung, das aktualisierende Object einen Methode, welche durch
einen Qt Makro als \textit{signal} ausgezeichnet ist. Bei Beobachter Objekten,
die auf dieses Signal reagieren sollen, wird dann eine als \textit{slot}
deklarierte Methode selbständig aufgerufen, sofern die Objekte, durch einen
Aufruf einer von Qt bereitgestellten, statischen Methode, verbunden wurden. 
Dieses Konzept vereinfacht die Entwicklung wegen seiner Flexibilität deutlich, allerdings ist der durch
Qt erzeugte Code, welcher bei Auflösung der Makros entsteht, aufblähend und
dadurch theoretisch langsamer bei der Ausführung als eine klassische callback Implementierung.
In der Praxis ist diese Verlangsamung aber unmerklich und wiegt nicht die
Vorteile für den Entwickler auf. Deshalb wurde das Konzept auch bei der Entwicklung von
\textit{Pathcompare} eingesetzt. 

Im Zusammenhang mit dem Signal-Slot Konzepts wurde bereits erwähnt, dass Qt C++
mit verschiedenen Makros erweitert. Diese Makros werden dabei nicht immer
direkt in gültigen C++ Code übersetzt, sondern dienen als Annotationen. Dies
hat Folgen für den Build Vorgang, denn die mit Annotationen versehenen Klassen
müssen dann zuerst, mit dem von Qt bereitgestelltem \gls{MOC} übersetzt werden.
Standardmäßig wird in \textit{Qt} das Build Programm qmake verwendet, welches
die nötigen Aufrufe des \gls{MOC} automatisch veranlasst. In Hinblick auf
\textit{Pathcompare} war aber eine Integration in das von \gls{ROS}
genutzte Build verfahren cmake notwendig. Hierbei muss beachtet werden,
dass cmake die Dateien welche einen \gls{MOC} Aufruf notwendig machen, in der
derzeitigen Version, nicht selbständig erkennt. Diese müssen manuell in der
\textit{CmakeLists.txt} deklariert werden. Die sonstige Einbindung
\textit{Qt} spezifischer Libraries und deren Verlinkung mit der Applikation ist
in cmake leicht möglich. Somit war die Verwenung von Qt in
\textit{pathcompare} kein Hindernis für die Verwendung von cmake.
Die Nutzung von cmake wird darüberhinaus, für große Projekte, von der 
Qt Dokumentation selbst empfohlen.
%TODO Quelle anbringen?

Neben dem \gls{MOC} existiert noch ein sogenannter \gls{UIC}. Dieser tritt im
Zusammenhang mit dem \textit{QtDesigner} in Erscheinung. Der
\textit{QtDesigner} ermöglicht es graphisch Qt GUIs zu erstellen. Dabei wird
eine XML Datei vom Designer erstellt, welche den Aufbau der GUI abbildet.
Der UIC ist dann dafür verantwortlich diese Datei in C++ Klassen zu übersetzen.
Auch hier muss cmake veranlasst werden zunächst für einen \gls{UIC} Aufruf
entsprechender Dateien zu sorgen.

\begin{itemize}
  \item Warum braucht Pathcompare Qt?
  \item GUI framework, native in C++ (auch Implementierungen für Java, Ruby,..)
  \item bietet auch zahlreiche nicht GUI spezifische Funktionalität
  \item cross platform
  \item native UI rendering
  \item UI designing with Qt Designer
  \item bereichert C++ durch embedded Macros (z.B. signal\&slot) -> moc compiler
  \item standard Buildsystem native qmake 
  \item Unterstützung für cmake gegeben, für große Projekte sogar empfohlen
\end{itemize}


\section{Design der Software}
Der Hauptfokus beim Design der GUI lag darauf, einfache Benutzung und
übersichtliche Darstellung, für den Nutzer zu gewährleisten.
Außerdem sollte die Software leicht erweiterbar sein.

\subsection{Überblick Gesamtsystem}

Im Folgendem wird die Software in einer Gesamtansicht dargestellt und
anschließend auf die Funktionsweise ihrer Einzelkomponenten genauer eingegangen.

Wie in vorherigen Teilen bereits erwähnt ist \textit{Pathcompare} durch
Plug-ins erweiterbar. Dadurch kann man zunächst das Gesamtsystem logisch in zwei Teile
untergliedern, nämlich in 

\begin{enumerate}
  \item Rahmen
  \item Plug-ins
\end{enumerate}

Diese Aufteilung spiegelt sich am offensichtlichsten auch in der GUI wider.
Hierbei bildet das UI des Rahmens die Grundlage für die Visualisierung von Plug-ins.
Dabei wird den Plug-ins, nachdem sie geladen wurden, ein Platz innerhalb des
Rahmens zugewiesen. Innerhalb dieses zugewiesenen Platzes können sie beliebige
eigene UI Elemente laden und haben die volle Kontrolle über diese. Konkret
gehören dabei Folgende UI Elemente zum Rahmen:

\begin{itemize}
\item Hauptfenster
\item Topic Übersicht
\item Plug-in Tab-Fenster
\end{itemize}

Das Hauptfenster dient dabei als Grundlage für die Topic Übersicht und das
Plug-in Tab-Fenster. Die Topic Übersicht und das Plug-in Tab-Fenster sind vertikal
getrennt. Die Topic-Ansicht ist dabei ganz links angeordnet, siehe   .
%TODO screenshot Gesamtansicht .
Rechts neben der Topic Übersicht schließt unmittelbar das Plug-in
Tab-Fenster an.
Wird ein Plug-in geladen, wird in diesem Tab-Fenster ein neuer Tab angelegt. Die
Fläche dieses Tabs wird diesem Plug-in dann zur Verfügung gestellt um sein UI
darauf aufzubauen. Auf Details bezüglich des Ladens der Plug-ins und deren
Funktionsweise wird in einem folgendem Abschnitt eingegangen. 
%TODO Referenz zu Plug-in Abschnitt

Die Topic Übersicht zeigt die momentan im \gls{ROS} verfügbaren Topics an. 
Um die Übersicht auf die Topics zu strukturieren ist sie derart
gestaltet, dass Topics desselben \textit{message} Typs gruppiert werden. Diese
Gruppen werden dann kompakt im Topic Übersicht Fenster angezeigt und können dort durch
den Nutzer aufgeklappt werden um alle \textit{topics} eines Typs anzuzeigen.
Dies ermöglicht es, nur solche Topics zu beobachten, die auch
tatsächlich relevant sind für den Nutzer. 

Die Platzaufteilung zwischen der Topic Übersicht und des Plug-in Tab-Fensters,
innerhalb des Hauptfensters, wurde zugunsten des Plug-in Tab-Fensters gewählt,
sodass dieses mehr Platz einnimmt.  Dies hat auch zur Folge, dass beim Vergrößern
des Hauptfensters, die Fläche des Plus-in Tab-Fensters vertikal und horizontal
vergrößert wird. Die eingenommene Fläche der Topic Übersicht wächst allerdings
nur vertikal wesentlich an. Diese Designentscheidung begründet sich darin,
dass die Plug-ins den wesentlichen Inhalt für den Nutzer präsentieren. Die
Topic Übersicht wird hingegen vermutlich nur kurzzeitig betrachtet werden und
liegt nicht im Zentrum des Interesses. Darüber hinaus ist die Topic Übersicht
sehr kompakt gestaltet und der horizontale Platzbedarf fällt gering aus.

%TODO screenshot des Rahmens mit topics einfügen


\subsection{Anbindung an ROS}

Die Hauptaufgabe des Rahmens ist es eine Anbindung an ROS zu gewährleisten.
Diese Anbindung muss es den Plug-ins ermöglichen, benötigte \textit{topics} zu
abbonieren. Für diese Anbindung ist in \textit{Pathcompare} die Klasse
\textit{ROSManager} verantwortlich. Im Konstruktor dieser Klasse wird durch
entsprechende \gls{ROS} API Aufrufe der \textit{node} \textit{pathcompare}
erstellt. Dies geschieht durch starten eines separaten Threads, da der ROS Code
in einer eigenen while-Schleife ausgeführt werden muss, die über die gesamte
Lebenszeit des \textit{nodes} bearbeitet wird. Innerhalb dieser Schleife wird
beispielsweise, das eintreffen neuer \textit{messages} von abonnierten
\textit{topics} abgearbeitet.
Zugriff der Plug-ins auf ROS spezifische Funktionalität wird komplett über den
\textit{ROSManager} gekapselt. Diese Zentralisierung ist deshalb nötig, umd den Zugriff
der verschiedenen Plug-ins, auf ROS, zu koordinieren. 
Die wichtigste Methode die durch den ROSManager dabei den Plug-ins zur
Verfügung steht, ermöglicht es eine als Parameter übergebene \textit{topic} zu
abbonieren. 
Diese Methode ist wie folgt definiert:
%TODO add figure message / topic handling gesamtübersicht
%TODO add method definition of ROSManager subscribeToTopic(..)

Beim Abonnieren einer \textit{topic} wird in ROS typischerweise direkt eine
Methode als Callback angegeben, welche eingehende \textit{messages} bearbeitet.
Bei einer einfachen Abbonierung ist es dabei zunächst nicht möglich mehrere
Callbacks zu registrieren.
In \textit{Pathcompare} bestehtehen in dieser Hinsicht allerdings zwei
Schwierigkeitn denen bei der Entwicklung begnet werden musste:

\begin{enumerate}
  \item eventuell abbonieren mehrere Plug-ins eine topic
  \item topics können von beliebigem \textit{message} Typ sein
\end{enumerate}

Gelöst wurde das Problem durch die Verwendung von
\textit{ros::message\_filter::cache}. Objekten dieser Klasse wird bei der
Initialisierung eine \textit{topic} zugewiesen. Empfangene \textit{messages}
dieser \textit{topic} werden in einem Ringpuffer mit einstellbarer größe Zwischengespeichert.
Außerdem erlaubt diese Klasse die Registrierung beliebig vieler Callbacks.
Der \textit{ROSManager} sorgt also dafür, dass für jede von den Plug-ins
benötigte \textit{topic} genau ein \textit{ros::message\_filter::cache} Objekt
existiert. Plug-ins erhalten dann einen Verweis auf dieses Objekt und können
ihren Callback registrieren.

Weitere Methoden die der ROSMaster den Plug-ins zur Verfügung stellt, werden in einem
späteren Abschnitt aufgezeigt.

Die Klasse \textit{ROSManager} sorgt außerdem dafür, dass die Topic Übersicht
regelmäßig aufgefrischt wird. Es wird also dem Nutzer ersichtlich, sollten neue
\textit{topics} erscheinen oder wenn diese nicht mehr verfügbar sind.
Da die \gls{ROS} \gls{API} keinen event service anbietet um Beobachter zu benachrichtigen,
falls sich der Status von \textit{topics} ändert, stellt der
\textit{ROSManager} sekündlich eine Anfrage an den \textit{master} nach dem
aktuellen Stand der topics.  Dies ist gesteuert über einen QTimer in Verbindung
mit dem Signal-Slot Konzept.


\subsection{Laden von Plugins}
Das Einbinden von Plugins in den Rahmen steuert die Klasse
\textit{PluginLoader}. Sie sucht dabei in einem Verzeichnis nach als Plug-in
infrage kommenden Dateien. Bei dieser Suche werden generell nur shared Library
Dateien betrachtet. Handelt es sich um eine für \textit{Pathcompare} gültige
Plug-in Datei, fragt der \textit{PluginLoader} zunächst den Namen des Plug-ins
über eine im Plug-in Interface spezifizierte Methode \textit{getName()} ab.
Anschließend wird im Plug-in Tab Fenster ein neuer Tab angelegt. Dabei wird im
Tab Reiter der erfragte Name des Plug-ins eingetragen. Dadurch sind in der GUI die Plug-ins für den
Nutzer leicht zu unterscheiden und können schnell angewählt werden.
Der Plug-in Ordner steht während der Laufzeit von \textit{Pathcompare}
unter der Beobachtung des \textit{PluginLoaders}. 
Obwohl \textit{Pathcompare} bereits gestartet wurde, können also Plug-ins in das Plug-in
Verzeichnis eingefügt werden und diese werden geladen. Dies bietet mehr Flexibilität für den
Nutzer und Entwickler, da kein Neustart der Rahmen Anwendung sowie der ausgeführten
\textit{Plug-ins} erforderlich ist.


\subsection{Main Compare Plug-in}
\label{sub:maincompare}


\textit{Main Compare} implementiert die eigentliche Hauptfunktionalität um Pfaddaten des
Referenzsystems und der Sensorknoten zu vergleichen und auszuwerten. 
Es ist dabei der Philosophie von \textit{Pathcompare} folgend auch als Plug-in
implementiert worden, welches beim Starten des Rahmens durch den
\textit{PluginLoader} geladen und ausgeführt wird.


\textit{Main Compare} implementiert dabei folgende features:

\begin{itemize}
  \item Abstandsbestimmung zu Referenzpfad
  \item Berechnung der Pfadlänge
  \item Item
  \item Export der Abstandsdaten
\end{itemize}

Als Grundlage für alle aufgeführten features dienen die über des ROS
bereitgestellten Pfad \textit{topics}.

%screenshot des Plugins
\begin{itemize}
  \item path message
  \item Funktionen erklären
  \item Referenz Pfad Selektion
  \item Tabellenansicht erklären
  \item Export (+Format der csv Datei)
\end{itemize}

\subsubsection{Pfadvergleichsverfahren}

%bild test mit Tickgeber

%bild variante ohne tick

%bild nav_msgs/Path message
\subsection{Plug-in Konzept allgemein}
\begin{itemize}
  \item allgemein Qt Plugins
  \item Vorstellen der Interfaces zum Schreiben eigener Plug-ins für Pathcompare
  \item Beispiel Camera Plugin
\end{itemize}
